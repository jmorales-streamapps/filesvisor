<!DOCTYPE html>
<html lang="es" data-bs-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.css">


    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <title>[[.Name]]</title>
    <style>
        .anclado {
            position: fixed;
            top: 3%;
            /*
            right: 10%;
            transform: translate(-50%, -50%);*/
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .chunk {
            width: 6px;
            height: 6px;
            background-color: white;
            margin: 2.5px;
        }

        .chunk-view {
            width: 6px;
            height: 6px;
            background-color: aqua;
            margin: 2.5px;
        }

        .DivWithScroll {
            height: 120px;
            overflow: scroll;
            overflow-x: hidden;
        }
    </style>

</head>

<body>

    <div class="container-fluid" id="app">
        <div class="row pt-3">
            <div class="col-9 pl-1">
                <div class="card p-1">

                    <div v-for="chunk in list_chunks" :key="chunk.id">

                        <div v-if="chunk.bytes.length != 0">
                            <div class="text-success" :id="'chunk_section_num_'+chunk.id">
                                Chunk {{chunk.id}}
                                <hr>
                            </div>


                            <div v-if="!pref_modelLine">
                                {{ convertirBytesATexto(chunk.bytes) }}
                            </div>
                            <div v-else>
                                <pre>
                                    <code class="language">{{ convertirBytesATexto(chunk.bytes) }}</code>
                                </pre>
                            </div>




                        </div>

                        <!--

                            asdasda
                        <pre>
                            <code class="language">// Tu código aquí
                            function saludar() {
                                console.log("Hola, mundo!");
                            }
                            </code>
                        </pre>
                        -->
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="anclado p-3">


                    <div class="card ">
                        <div class="card-header">
                            <a style="text-decoration:none" data-bs-toggle="collapse" href="#collapse_info"
                                role="button" aria-expanded="false" aria-controls="collapse_info">
                                Información del Archivo
                            </a>
                        </div>
                        <div class="collapse" id="collapse_info">
                            <ul class="list-group list-group-flush ">
                                <li class="list-group-item fs-6"><strong>Nombre del Archivo:</strong> <br> [[.Name]]
                                </li>
                                <li class="list-group-item"><strong>Fecha de Modificación:</strong> <br>
                                    {{dateF}}<br>{{humanDate}}</li>
                                <li class="list-group-item"><strong>Peso:</strong> <br>{{sizeFile}}</li>
                            </ul>
                        </div>

                    </div>


                    <br>

                    <div class="card">
                        <div class="card-header">

                            <a style="text-decoration:none" data-bs-toggle="collapse"
                                href="#collapse_reader_preferences" role="button" aria-expanded="false"
                                aria-controls="collapse_reader_preferences">
                                Preferencias de lectura
                            </a>
                        </div>
                        <div class="card-body">
                            <div class="collapse" id="collapse_reader_preferences">
                                <div class="btn-group" role="group" aria-label="">
                                    <input type="radio" class="btn-check" name="por_linea_chunk" id="chunk"
                                        v-model="pref_opcion" value="por_chunks" autocomplete="off" checked>
                                    <label class="btn btn-outline-primary" for="chunk">Por chunks</label>

                                    <input type="radio" class="btn-check" name="por_linea_chunk" id="linea"
                                        v-model="pref_opcion" value="por_lineas" autocomplete="off">
                                    <label class="btn btn-outline-primary" for="linea">Por lineas</label>
                                </div>

                                <div v-if="pref_opcion === 'por_chunks'">
                                    <div class="p-3">
                                        <small>Cualquier cambio recargará la página</small>
                                    </div>


                                    <div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="peso_chunk"
                                                id="peso_max1" v-model="pref_peso_chunk" value="10000">
                                            <label class="form-check-label" for="peso_max1">
                                                10kb
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="peso_chunk"
                                                id="peso_max2" v-model="pref_peso_chunk" value="50000">
                                            <label class="form-check-label" for="peso_max2">
                                                50kb
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="peso_chunk"
                                                id="peso_max3" v-model="pref_peso_chunk" value="100000">
                                            <label class="form-check-label" for="peso_max3">
                                                100kb
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="peso_chunk"
                                                id="peso_max4" v-model="pref_peso_chunk" value="500000">
                                            <label class="form-check-label" for="peso_max4">
                                                500kb
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="peso_chunk"
                                                id="peso_max5" v-model="pref_peso_chunk" value="1000000">
                                            <label class="form-check-label" for="peso_max5">
                                                1Mb
                                            </label>
                                        </div>
                                        <br>
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" role="switch" id="modeline"
                                                v-model="pref_modelLine">
                                            <label class="form-check-label" for="modeline">Modo de líneas</label>
                                        </div>

                                    </div>
                                    <div class="p-3">
                                        <div class="progress" role="progressbar" aria-label="Warning example"
                                            aria-valuenow="{{contador_reinicio}}" aria-valuemin="0" aria-valuemax="100">
                                            <div class="progress-bar" :style="{ width: contador_reinicio + '%' }">
                                                {{contador_reinicio}}%</div>
                                        </div>
                                    </div>
                                </div>
                                <div v-else-if="pref_opcion === 'por_lineas'">
                                    <br>
                                    <br>
                                    <p>Texto correspondiente a la opción 'Por líneas'.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <br>


                    <div class="card p-3">


                        <div class="card-header banner">
                            <div v-if="mostrar">
                                Chunk: {{chunkinf.id}} {{chunkinf.status}}
                            </div>
                            <div v-if="!mostrar">
                                Chunk:
                            </div>
                        </div>


                        <div class="DivWithScroll">
                            <div class="d-flex flex-wrap">
                                <div v-for="chunk in list_chunks" :key="chunk.id">
                                    <!-- Puedes personalizar el contenido de cada elemento aquí
                            <p>Elemento {{ elemento }}</p>
                            -->
                                    <div v-if="chunk.status === statusChunk.emty" class="chunk"
                                        @mouseover="showInf(true, chunk)" @mouseout="showInf(false, chunk)"
                                        @click="fetchDataFromAPI(chunk)" style="cursor: pointer;"></div>



                                    <div v-if="chunk.status === statusChunk.loaded" class="chunk-view"
                                        @mouseover="showInf(true, chunk)" @mouseout="showInf(false, chunk)"
                                        @click="fetchDataFromAPI(chunk)" style="cursor: pointer;">

                                    </div>


                                </div>
                            </div>
                        </div>

                    </div>


                </div>
            </div>
        </div>



    </div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <script src="https://momentjs.com/downloads/moment.min.js"></script>
    <script src="https://momentjs.com/downloads/moment-with-locales.js"></script>


    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-scrollto"></script>



    <script>hljs.highlightAll();</script>

    <script>
        const statusChunk = {
            emty: 'emty',
            error: 'error',
            loaded: 'loaded'
        }
        class Chunk {
            constructor(id, startByte, endByte, bytes) {
                this.id = id;
                this.fileReference = '[[.Reference]]';
                this.startByte = startByte;
                this.endByte = endByte;
                this.bytes = bytes;
                this.status = statusChunk.emty;

            }

            toString() {
                return `Chunk ${this.id}: Bytes ${this.startByte} - ${this.endByte}, ${this.bytes.length} bytes`;
            }
        }




        function formatBytes(bytes, decimals) {
            if (bytes == 0) return '0 Bytes';
            var k = 1024,
                dm = decimals || 2,
                sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
                i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }




        async function fetchDataFromAPI(chunk) {

            console.log(`id CHUNK: ${chunk}`);
            if (chunk.bytes.length != 0) {
                /*
                setTimeout(() => {
                    document.getElementById(`chunk_section_num_${chunk.id}`).scrollIntoView({ behavior: 'smooth' });

                }, 2000)
                */
                VueScrollTo.scrollTo(`#chunk_section_num_${chunk.id}`, 500, {});
            } else {

                const data = {
                    reference: chunk.fileReference,
                    from: chunk.startByte,
                    to: chunk.endByte
                };
                fetch('/chunk/chunk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data),
                })
                    .then(response => {
                        //console.log('Respose');
                        //console.log(typeof response);
                        if (!response.ok) {
                            throw new Error(`Error de red - Código: ${response.status}`);
                        }
                        return response.arrayBuffer(); // Puedes cambiar esto según el tipo de respuesta que esperas
                    })
                    .then(data => {
                        // Maneja los datos de la respuesta aquí
                        console.log('Respuesta:', data);
                        chunk.bytes = data
                        chunk.status = statusChunk.loaded;
                        /*
                        setTimeout(() => {
                            document.getElementById(`chunk_section_num_${chunk.id}`).scrollIntoView({ behavior: 'smooth' });

                        }, 2000)*/
                    })
                    .catch(error => {
                        // Maneja los errores aquí
                        console.error('Error en la solicitud:', error);
                        chunk.status = statusChunk.error;

                    });
            }


        }

        function calcularChunks(tamanoArchivo, tamanoFragmento) {
            return Math.ceil(tamanoArchivo / tamanoFragmento);
        }


        function convertirBytesATexto(bytes) {
            const decoder = new TextDecoder('utf-8');
            const texto = decoder.decode(new Uint8Array(bytes));
            return texto;
        }


        function changeSizeChunk(newSize) {
            fetch('/preferences/chunk', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    sizeChunk: parseInt(newSize)
                }),
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error de red - Código: ${response.status}`);
                    }
                    return response.text(); // Puedes cambiar esto según el tipo de respuesta que esperas
                })
                .then(data => {
                    console.log('Respuesta:', data);
                    window.location.reload();

                })
                .catch(error => {
                    // Maneja los errores aquí
                    console.error('Error en la solicitud:', error);
                });
        }


        function preferenceModeline(activate) {
            fetch('/preferences/modeline', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    modeLine: activate
                }),
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error de red - Código: ${response.status}`);
                    }
                    return response.text();
                })
                .then(data => {
                    console.log('Respuesta:', data);
                    // window.location.reload();
                })
                .catch(error => {
                    // Maneja los errores aquí
                    console.error('Error en la solicitud:', error);
                });
        }







    </script>

    <script>
        const { createApp, ref, watch, computed, use } = Vue
        // console.log(VueScrollTo);

        moment.locale('es');
        let temporizador;




        app = createApp({
            setup() {
                const pref_modelLine = ref("[[.Prefs.ModeLine]]")
                const contador_reinicio = ref(0);
                const pref_peso_chunk = ref(parseInt("[[.Prefs.SizeChunk]]"))
                const pref_opcion = ref('por_chunks');

                const mostrar = ref(false);
                const chunkinf = ref(new Chunk(0, 0, 0, new Uint8Array([])));
                // const list_chunks = [];
                const date = moment(parseFloat("[[.ModTime]]"));
                const dateF = date.format('MMMM Do YYYY, h:mm:ss a');
                let tamanoFragmento = pref_peso_chunk.value;

                // console.log(date.fromNow());

                const sizeFile = ref(formatBytes('[[.Size]]' != '' ? '[[.Size]]' : '0'))
                const humanDate = ref(date.fromNow())
                // const fetchChunkFromAPI = fetchDataFromAPI;
                let sizeFileServ = parseInt("[[.Size]]")

                // Calcular el número de chunks
                const numeroChunks = calcularChunks(sizeFileServ, tamanoFragmento);

                // Crear la lista de chunks
                const list_chunks = ref(
                    Array.from({ length: numeroChunks }, (_, index) => {
                        const startByte = tamanoFragmento * index;
                        let endByte = startByte + tamanoFragmento;
                        if (endByte >= sizeFileServ) {
                            endByte = sizeFileServ
                        }
                        return new Chunk(index, startByte, endByte, new Uint8Array([]));
                    })
                );


                const showInf = (m, c) => {
                    console.log("Mostrar o ocultar");
                    mostrar.value = m;

                    if (mostrar.value) {
                        chunkinf.value = c;
                    }
                }


                function watch_v2(varrr, funtionnnn) {
                    watch(varrr, (nuevoValor, viejoValor) => {
                        // console.log(`pref_peso_chunk: ${nuevoValor}-${viejoValor}`);
                        if (nuevoValor !== viejoValor) {
                            if (temporizador != null || temporizador != undefined) {
                                clearInterval(temporizador);
                                contador_reinicio.value = 0;
                            } else {
                                console.log('temporizador::::::::::::::: ', temporizador);
                            }

                            temporizador = setInterval(() => {
                                contador_reinicio.value = contador_reinicio.value + 33;
                                if (contador_reinicio.value >= 100) {
                                    clearInterval(temporizador);
                                    funtionnnn();

                                }
                            }, 1000);
                        }
                    });
                }

                watch_v2(pref_peso_chunk, () => {
                    changeSizeChunk(pref_peso_chunk.value)
                })

                /*
                watch_v2(pref_modelLine, () => {

                    preferenceModeline(pref_modelLine.value)
                })
                */
                watch(pref_modelLine, (nuevoValor, viejoValor) => {
                    // console.log(`pref_peso_chunk: ${nuevoValor}-${viejoValor}`);
                    if (nuevoValor !== viejoValor) {
                        preferenceModeline(pref_modelLine.value)
                    }
                })






                return {
                    sizeFile,
                    humanDate,
                    dateF,
                    list_chunks,
                    fetchDataFromAPI,
                    convertirBytesATexto,
                    showInf,
                    mostrar,
                    chunkinf,
                    pref_opcion,
                    pref_peso_chunk,
                    contador_reinicio,
                    statusChunk,
                    pref_modelLine

                }
            }
        })

        app.use(VueScrollTo)
        app.mount('#app')

    </script>
</body>

</html>